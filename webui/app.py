"""
Flask Web Dashboard for Coop Camera
Provides 10 different UI variants for viewing camera streams, stats, and recorded videos
"""
from flask import Flask, render_template, Response, jsonify, send_from_directory
import requests
import os
import re
from datetime import datetime
import threading
import time
from collections import deque

app = Flask(__name__,
            static_folder='dist',
            static_url_path='')

# Configuration
COOPCAM_API_URL = os.getenv('COOPCAM_API_URL', 'http://192.168.1.104:5001')
CAMERA_RESOLUTION = {'width': 1280, 'height': 720}
CAMERA_STREAM_URL = 'http://192.168.1.104:5001/basicstream_feed'

# Shared camera stream manager
class CameraStreamManager:
    def __init__(self, camera_url):
        self.camera_url = camera_url
        self.frame = None
        self.frame_lock = threading.Lock()
        self.is_running = False
        self.thread = None
        self.clients = []
        self.last_frame_time = None

    def start(self):
        """Start the background thread that fetches frames from the camera"""
        if self.is_running:
            return

        self.is_running = True
        self.thread = threading.Thread(target=self._fetch_frames, daemon=True)
        self.thread.start()
        print(f"üìπ Camera stream manager started for {self.camera_url}")

    def _fetch_frames(self):
        """Background thread that continuously fetches frames from camera"""
        retry_delay = 5  # seconds between retries

        while self.is_running:
            try:
                print(f"üîÑ Connecting to camera at {self.camera_url}...")
                with requests.get(self.camera_url, stream=True, timeout=10) as r:
                    r.raise_for_status()
                    print(f"‚úÖ Connected to camera stream")

                    # Read MJPEG stream
                    bytes_data = bytes()
                    for chunk in r.iter_content(chunk_size=4096):
                        if not self.is_running:
                            break

                        bytes_data += chunk

                        # Find JPEG boundaries
                        a = bytes_data.find(b'\xff\xd8')  # JPEG start
                        b = bytes_data.find(b'\xff\xd9')  # JPEG end

                        if a != -1 and b != -1:
                            jpg = bytes_data[a:b+2]
                            bytes_data = bytes_data[b+2:]

                            # Update shared frame
                            with self.frame_lock:
                                self.frame = jpg
                                self.last_frame_time = time.time()

            except requests.exceptions.RequestException as e:
                print(f"‚ùå Camera connection error: {e}")
                print(f"‚è≥ Retrying in {retry_delay} seconds...")
                time.sleep(retry_delay)
            except Exception as e:
                print(f"‚ùå Unexpected error in camera stream: {e}")
                time.sleep(retry_delay)

    def get_frame(self):
        """Get the latest frame (thread-safe)"""
        with self.frame_lock:
            return self.frame

    def stop(self):
        """Stop the background thread"""
        self.is_running = False
        if self.thread:
            self.thread.join(timeout=2)

# Global camera manager instance
camera_manager = CameraStreamManager(CAMERA_STREAM_URL)
camera_manager.start()

def get_vite_assets():
    """Parse index.html to get the actual asset filenames generated by Vite"""
    index_path = os.path.join(app.static_folder, 'index.html')

    if not os.path.exists(app.static_folder):
        print(f"ERROR: dist folder not found at {app.static_folder}")
        print("Please run: npm run build")
        return {'js': '/assets/index.js', 'css': '/assets/index.css', 'error': True}

    if os.path.exists(index_path):
        with open(index_path, 'r') as f:
            content = f.read()
            # Extract JS file (matches both index-*.js and main-*.js patterns)
            js_match = re.search(r'src="(/assets/[^"]+\.js)"', content)
            # Extract CSS file (matches both index-*.css and main-*.css patterns)
            css_match = re.search(r'href="(/assets/[^"]+\.css)"', content)

            assets = {
                'js': js_match.group(1) if js_match else '/assets/index.js',
                'css': css_match.group(1) if css_match else '/assets/index.css'
            }
            print(f"Loaded assets: {assets}")
            return assets

    print(f"ERROR: index.html not found at {index_path}")
    print("Please run: npm run build")
    return {'js': '/assets/index.js', 'css': '/assets/index.css', 'error': True}

@app.route('/')
def index():
    """Main dashboard page"""
    assets = get_vite_assets()
    return render_template('index.html', assets=assets)

# API endpoints for data
@app.route('/api/stats')
def get_stats():
    """Get camera and system statistics"""
    stats = {
        'camera': {
            'status': 'online',
            'fps': 30,
            'resolution': f"{CAMERA_RESOLUTION['width']}x{CAMERA_RESOLUTION['height']}",
            'uptime': '24h 15m'
        },
        'detections': {
            'today': 127,
            'this_week': 856,
            'this_month': 3420
        },
        'system': {
            'cpu': 45,
            'memory': 62,
            'storage': 78,
            'temperature': 42
        },
        'models': {
            'active': 'model4',
            'available': ['model1', 'model2', 'model3', 'model4', 'nodetect']
        }
    }
    return jsonify(stats)

@app.route('/api/videos')
def get_videos():
    """Get list of recorded videos"""
    # Mock data - in production this would scan a recordings directory
    videos = [
        {
            'id': 1,
            'filename': 'recording_2025-01-08_14-30.mp4',
            'timestamp': '2025-01-08 14:30:45',
            'duration': '00:05:23',
            'size': '45.2 MB',
            'thumbnail': '/api/thumbnail/1'
        },
        {
            'id': 2,
            'filename': 'recording_2025-01-08_09-15.mp4',
            'timestamp': '2025-01-08 09:15:12',
            'duration': '00:03:47',
            'size': '32.8 MB',
            'thumbnail': '/api/thumbnail/2'
        },
        {
            'id': 3,
            'filename': 'recording_2025-01-07_18-45.mp4',
            'timestamp': '2025-01-07 18:45:33',
            'duration': '00:07:15',
            'size': '61.5 MB',
            'thumbnail': '/api/thumbnail/3'
        },
        {
            'id': 4,
            'filename': 'recording_2025-01-07_12-20.mp4',
            'timestamp': '2025-01-07 12:20:08',
            'duration': '00:04:52',
            'size': '41.3 MB',
            'thumbnail': '/api/thumbnail/4'
        },
        {
            'id': 5,
            'filename': 'recording_2025-01-06_16-05.mp4',
            'timestamp': '2025-01-06 16:05:22',
            'duration': '00:06:38',
            'size': '56.7 MB',
            'thumbnail': '/api/thumbnail/5'
        }
    ]
    return jsonify(videos)

@app.route('/api/camera/stream')
def proxy_camera_stream():
    """
    Broadcast camera stream to multiple clients.
    All clients share a single connection to the actual camera.
    """
    def generate():
        print(f"üì∫ New client connected to stream")
        last_frame = None

        try:
            while True:
                # Get latest frame from shared manager
                frame = camera_manager.get_frame()

                if frame and frame != last_frame:
                    # Send frame in MJPEG format
                    yield (b'--frame\r\n'
                           b'Content-Type: image/jpeg\r\n\r\n' + frame + b'\r\n')
                    last_frame = frame

                # Small sleep to avoid tight loop
                time.sleep(0.033)  # ~30 FPS

        except GeneratorExit:
            print(f"üì∫ Client disconnected from stream")
        except Exception as e:
            print(f"‚ùå Stream error for client: {e}")

    return Response(
        generate(),
        mimetype='multipart/x-mixed-replace; boundary=frame',
        headers={
            'Cache-Control': 'no-cache, no-store, must-revalidate',
            'Pragma': 'no-cache',
            'Expires': '0'
        }
    )

@app.route('/api/thumbnail/<video_id>')
def get_thumbnail(video_id):
    """Get video thumbnail (mock endpoint)"""
    # In production, this would return actual video thumbnails
    return jsonify({'placeholder': True, 'video_id': video_id})

@app.route('/api/detections')
def get_detections():
    """Proxy detections from coopcam.py database"""
    try:
        # Get data from coopcam.py API
        detections_url = f'{COOPCAM_API_URL}/api/return_all_detections'
        response = requests.get(detections_url, timeout=5)
        response.raise_for_status()
        return jsonify(response.json())
    except Exception as e:
        print(f"Failed to fetch detections from {COOPCAM_API_URL}: {e}")
        # Return empty data if coopcam.py is not available
        return jsonify({'detections': [], 'count': 0, 'error': str(e)})

# Serve React app
@app.route('/<path:path>')
def serve_static(path):
    """Serve static files from React build"""
    return send_from_directory(app.static_folder, path)

if __name__ == '__main__':
    print("\n" + "="*60)
    print("üêî Coop Colonel Dashboard")
    print("="*60)
    print(f"üì° Dashboard: http://localhost:5000")
    print(f"üé• Camera stream (broadcast): /api/camera/stream")
    print(f"   ‚îî‚îÄ Source: {CAMERA_STREAM_URL}")
    print(f"   ‚îî‚îÄ Mode: Single connection shared across all clients")
    print(f"üìä Detection API: {COOPCAM_API_URL}/api/return_all_detections")
    print(f"\nüí° Stream uses broadcast mode - unlimited tabs supported!")
    print(f"‚ö†Ô∏è  Make sure coopcam.py is running at {COOPCAM_API_URL}")
    print("="*60 + "\n")

    try:
        app.run(debug=True, host='0.0.0.0', port=5000)
    finally:
        print("\nüõë Shutting down camera stream manager...")
        camera_manager.stop()
